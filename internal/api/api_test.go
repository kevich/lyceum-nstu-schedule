package api

import (
	"fmt"
	"kevich/lyceum-nstu-schedule/tools"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
)

const scheduleHtml = `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<title>Школьное расписание</title>
<meta name="keywords" content="Школьное расписание НИКА-Люкс НИКА-Софт">
<script type="text/javascript" src="nika_data_09022025_132746.js"></script>
<script type="text/javascript" src="schedule.js"></script>
</head>
<body></body>
</html>`

func TestApiGetData(t *testing.T) {
	json := `{
    "VERTICAL_CLASSES": false,
    "SHOW_TEACHERS": true,
    "SECOND_RELATIVE": true,
    "STRIKEOUT_FREE_LSN": true,
    "SHOW_EXCHANGES_TERM": true,
    "DISABLE_LINK_LOGO": true,
}`
	rawJS := []byte(`// nika_data.js;  description: schedule in JSON format
// this file automatically generated by Nika-Soft(c) products

var NIKA=
%s;`)
	serverMux := http.NewServeMux()
	serverMux.HandleFunc("/rasp/schedule.html", func(rw http.ResponseWriter, r *http.Request) {
		_, err := fmt.Fprintln(rw, scheduleHtml)
		tools.CheckError(err, "failed returning response")
	})
	serverMux.HandleFunc("/rasp/nika_data_09022025_132746.js", func(rw http.ResponseWriter, r *http.Request) {
		_, err := fmt.Fprintln(rw, fmt.Sprintf(string(rawJS), json))
		tools.CheckError(err, "failed returning response")
	})
	server := httptest.NewServer(serverMux)
	defer server.Close()

	api := ScheduleAPI{server.Client(), server.URL}
	response, err := api.ApiGetData()
	assert.NoError(t, err, "failed returning response")
	assert.Equal(t, json, string(response), "failed returning response")
}

func TestApiGetDataChecksScheduleBody(t *testing.T) {
	server := httptest.NewServer(http.HandlerFunc(func(rw http.ResponseWriter, r *http.Request) {
		_, err := fmt.Fprintln(rw, nil)
		tools.CheckError(err, "failed returning response")
	}))
	defer server.Close()

	api := ScheduleAPI{server.Client(), server.URL}
	response, err := api.ApiGetData()
	assert.Error(t, err, "failed returning response")
	assert.Nil(t, response)
}

func TestApiGetDataNilBody(t *testing.T) {
	customTransport := &mockRoundTripperWithNilBody{}
	client := &http.Client{
		Transport: customTransport,
	}

	api := ScheduleAPI{Client: client, BaseURL: "http://example.com"}
	response, err := api.ApiGetData()
	assert.Error(t, err, "should return error when response body is nil")
	assert.Nil(t, response)
	if err != nil && err.Error() != "could not get schedule body" {
		assert.Contains(t, err.Error(), "could not find schedule file",
			"if body is normalized, should fail at schedule file check")
	} else {
		assert.Contains(t, err.Error(), "could not get schedule body")
	}
}

type mockRoundTripperWithNilBody struct{}

func (m *mockRoundTripperWithNilBody) RoundTrip(req *http.Request) (*http.Response, error) {
	resp := &http.Response{
		StatusCode:    http.StatusOK,
		Body:          nil,
		Header:        make(http.Header),
		Request:       req,
		Proto:         "HTTP/1.1",
		ProtoMajor:    1,
		ProtoMinor:    1,
		ContentLength: 0,
	}
	return resp, nil
}

func TestApiGetDataNoScheduleData(t *testing.T) {
	jsFileWithoutNika := `// nika_data.js;  description: schedule in JSON format
// this file automatically generated by Nika-Soft(c) products

var someOtherVar = {};`

	serverMux := http.NewServeMux()
	serverMux.HandleFunc("/rasp/schedule.html", func(rw http.ResponseWriter, r *http.Request) {
		_, err := fmt.Fprintln(rw, scheduleHtml)
		tools.CheckError(err, "failed returning response")
	})
	serverMux.HandleFunc("/rasp/nika_data_09022025_132746.js", func(rw http.ResponseWriter, r *http.Request) {
		_, err := fmt.Fprintln(rw, jsFileWithoutNika)
		tools.CheckError(err, "failed returning response")
	})
	server := httptest.NewServer(serverMux)
	defer server.Close()

	api := ScheduleAPI{server.Client(), server.URL}
	response, err := api.ApiGetData()
	assert.Error(t, err, "should return error when schedule data is not found")
	assert.Nil(t, response)
	assert.Contains(t, err.Error(), "could not find schedule data")
}

type mockRoundTripper struct {
	response *http.Response
	err      error
}

func (m *mockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	if m.err != nil {
		return nil, m.err
	}
	resp := &http.Response{
		StatusCode:    m.response.StatusCode,
		Body:          nil, // Explicitly set to nil
		Header:        m.response.Header,
		Request:       req, // Set to the actual request
		Proto:         m.response.Proto,
		ProtoMajor:    m.response.ProtoMajor,
		ProtoMinor:    m.response.ProtoMinor,
		ContentLength: m.response.ContentLength,
	}
	return resp, nil
}
